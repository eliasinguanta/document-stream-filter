<template>
  <div class="container mt-5">

    <!-- Table displaying uploaded documents only if there are documents -->
    <div v-if="uploadedDocuments.length > 0">
      <table class="table">
        <thead>
          <tr>
            <th scope="col"></th>
            <th scope="col">Name</th>
            <th scope="col">Size</th>
            <th scope="col"></th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="(doc, index) in paginatedDocuments" :key="index">
            <th scope="row">{{ (currentPage - 1) * pageSize + index + 1 }}</th>
            <td>{{ doc.name }}</td>
            <td>{{ doc.size }} bytes</td>
            <td>
              <button class="btn btn-danger btn-sm" @click="deleteFile(doc.name)">Delete</button>
              <button class="btn btn-success btn-sm ms-2" @click="downloadFile(doc.name)">Download</button>
            </td>
          </tr>
        </tbody>
      </table>

      <!-- Pagination Controls -->
      <div class="d-flex justify-content-between align-items-center mt-3">
        <button class="btn btn-secondary" :disabled="currentPage === 1" @click="currentPage--">Zurück</button>
        <span>Seite {{ currentPage }} von {{ totalPages }}</span>
        <button class="btn btn-secondary" :disabled="currentPage === totalPages" @click="currentPage++">Weiter</button>
      </div>
    </div>

    <div class="mt-4">

      <!-- File upload form -->
      <div class="mb-3">
        <input type="file" class="form-control" @change="setUploadDocument" ref="fileInput" />
      </div>

      <!-- Button to upload the document -->
      <div class="d-flex gap-2">
        <button class="btn btn-primary" @click="uploadDocument">Upload document</button>

        <button class="btn btn-secondary" @click="uploadRandomDocuments">Upload 200 random documents</button>

        <button class="btn btn-danger" @click="deleteAllFiles">Delete All</button>
      </div>
    </div>

  </div>
</template>
<script setup>
import { ref, onMounted, computed } from "vue";

const selectedFile = ref(null);
const uploadedDocuments = ref([]);
const currentPage = ref(1)
const pageSize = ref(5)

// Calculate the number of paginated pages
const totalPages = computed(() => {
  return Math.ceil(uploadedDocuments.value.length / pageSize.value)
})

// Update the documents that are displayed on the current page
const paginatedDocuments = computed(() => {
  const start = (currentPage.value - 1) * pageSize.value
  const end = start + pageSize.value
  return uploadedDocuments.value.slice(start, end)
})


const setUploadDocument = (event) => {
  selectedFile.value = event.target.files[0];
};

// send the request to upload 200 random documents generated by the server
// This function is called when the upload random documents button is clicked
const uploadRandomDocuments = async () => {
  try {
    const response = await fetch("/randomFiles", {
      method: "POST",
    });

    if (response.ok) {
      const data = await response.json();

      uploadedDocuments.value.push(
        ...data.map(doc => ({
          name: doc.documentName,
          size: doc.size,
        }))
      );

    } else {
      alert("Upload failed: " + response.status);
    }
  } catch (error) {
    alert("An error occurred while uploading the file: " + error.message);
  }
}

// upload a single document
// This function is called when the upload button is clicked
const uploadDocument = async () => {

  if (!selectedFile.value) {
    alert("Please select a file to upload.");
    return;
  }
  if (selectedFile.value.type !== "text/plain") {
    alert("Please select a text file");
    selectedFile.value = null;
    return;
  }

  const formData = new FormData();
  formData.append("file", selectedFile.value);

  try {
    const response = await fetch("/files", {
      method: "POST",
      body: formData,
    });

    if (response.ok) {
      const data = await response.json();


      uploadedDocuments.value.push({
        name: data.documentName,
        size: data.size,
      });

    } else {
      alert("Upload failed: " + response.status);
    }
  } catch (error) {
    alert("An error occurred while uploading the file: " + error.message);
  }

  // reset
  selectedFile.value = null;
};

// get the list of uploaded documents
// This function is called when the component is mounted
const fetchFiles = async () => {
  try {
    const response = await fetch("/files");
    const data = await response.json();
    uploadedDocuments.value = data.files.map((file) => ({
      name: file.documentName,
      size: file.size,
    }));
  } catch (error) {
    alert("Error fetching files: " + error.message);
  }
};

// delete a single document from the server and client
// This function is called when the delete button next to a document is clicked
// The document is identified by its name
const deleteFile = async (filename) => {
  try {
    const response = await fetch(`/files/${filename}`, {
      method: "DELETE",
    });

    if (response.ok) {
      console.log(`File ${filename} deleted successfully`);
      fetchFiles();  // Nach dem Löschen die Dateien erneut abrufen
    } else {
      alert("Error deleting file.");
    }
  } catch (error) {
    console.error("Error deleting file:", error);
    alert("An error occurred while deleting the file.");
  }
};

// delete all documents from the server and client
// This function is called when the delete all button is clicked
// The documents are identified by their names
const deleteAllFiles = async () => {
  try {
    if (!confirm('Are you sure you want to delete all documents?')) return;

    const response = await fetch("/files", {
      method: "DELETE",
    });

    if (response.ok) uploadedDocuments.value = [];

  } catch (error) {
    console.error('Error deleting all documents:', error);
  }
};

// download a single document
// This function is called when the download button next to a document is clicked
// The document is identified by its name
const downloadFile = (filename) => {
  window.location.href = `/files/${filename}`;
};

onMounted(() => {
  fetchFiles();
});
</script>
